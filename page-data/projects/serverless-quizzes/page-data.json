{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/projects/serverless-quizzes/","result":{"data":{"markdownRemark":{"html":"<h1>Serverless multi-choice quiz API!</h1>\n<h2>Tldr;</h2>\n<p>I used AWS to create a serverless API for multi choice quizzes you can play with your friends.\nUsing Amazons Lambda and API Gateway, players of the game are able to share a link with their friends,\nestablish a web socket connection to my backend and have new rounds broadcasted to them in real\ntime! You can check out my final web app at <a href=\"https://app.admiradoco.com\">app.admiradoco.com</a></p>\n<h2>The Beginnings</h2>\n<p>This project began when I decided that I wanted to learn about deploying a service completely\nserverless. I wanted to create something in my free time, but didn't want to be paying any money.\nBecause amazons pricing for Api Gateway and Lambda was only pay for what you use, I thought this\nwould be a perfect fit.</p>\n<p>When I first started this project, I knew I wanted to make something with game state. This was going\nto be give me the best opportunity to use different technologies and expand on my knowledge base.</p>\n<p>Choosing a serverless framework, I found two popular choices. The <strong>Serverless Framework</strong> which\nappears to have be first on the scene, and Amazons own <strong>SAM</strong> (Serverless Application Model)\nframework. I preferred sam, as it was native to Amazon, and the only costs were what was hosted in\nthe cloud.</p>\n<h2>Backend</h2>\n<h3>Getting Started</h3>\n<p>Like you always should when you create your first project with a new technology, I created my Hello\nWorld. This was relatively straight forward with the <code>sam init</code> command. Something that originally\nappealed to me about SAM was that it allowed me to test my functions locally by mocking api gateway.\nI was able to test my Hello World, but i wasn't satisfied. Hello Worlds are easy, the real getting\nstarted is do have a base for the project you want to work on.</p>\n<p>I followed the Amazon docs, and created myself a very simple Rest Api. You would GET /health and\nbe returned with 200, OK. SAM has a template file which is an abstraction over amazons Cloudformation\nfile. It allows you to describe a service in fewer lines, and then sam interprets it and uploads\nthe template file that Cloudformation understands. Once I built and deployed the code, Api Gateway\ncreated me a URL and I was able to invoke my lambda function which handled the request.</p>\n<p>This is a snippet of what I had to define for provisioning my cloud resources</p>\n<pre><code># template.yaml\n...\nResources:\n  GameFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: src/hello-world\n      Handler: app.handler\n      Events:\n        GetHealthApi:\n          Type: Api\n          Properties:\n            Path: /health\n            Method: get\nOutputs:\n  Api:\n    Description: \"API Gateway endpoint URL\"\n    Value: !Sub \"https://${RestApiGateway}.execute-api.${AWS::Region}.amazonaws.com/api\"\n</code></pre>\n<h3>Implementing my first APIs</h3>\n<p>My next goal was to be able to /GET Game and /POST Game. For this I going to need the APIs and a\ndatabase for persisting the games.</p>\n<p>When choosing my database I wanted free, managed and NoSql. As I'm already using AWS for my cloud\nservices, I decided on Dynamo DB.</p>\n<p>The great thing about serverless applications is you can tear things down and spin them back up\nso easily and quickly. I decided that a development and production environment best let me utilise a\nworkflow of tearing down the Api and spinning it back up as much as I want. I did this by declaring\ndifferent parameters passed into my template.yaml file, which would create me a dev or prod\ndatabase depending on the mode. Then I would map the database name depending on my environment\ninside the template.yaml file.</p>\n<pre><code>Mappings:\n  EnvironmentMap:\n    dev:\n      gamesTable: games-dev\n    prod:\n      gamesTable: games-prod\nGlobals:\n  Function:\n    Environment:\n      Variables:\n          GAMES_TABLE_NAME: !FindInMap [ EnvironmentMap, !Ref \"Environment\", gamesTable ]\n</code></pre>\n<p>At this point of the project my directory structure was looking something like this.</p>\n<pre><code>├── README.md\n├── docker-compose.yml           &#x3C;--- Start dynamo locally\n├── samconfig.toml               &#x3C;--- Sam cli configs\n├── src\n│   └── game                     &#x3C;--- Deployed to Lambda\n│       ├── app.js               &#x3C;--- Lambda entry point\n│       ├── dbClient.js\n│       ├── gamesTable.js\n│       ├── handlers\n│       │   ├── createGame.js    &#x3C;--- Handle /POST\n│       │   └── getGame.js       &#x3C;--- Handle /GET\n│       ├── models\n│       │   └── Game.js\n│       └── package.json\n└── template.yaml                &#x3C;--- Cloud formation\n</code></pre>\n<p>However, I was already starting to see a problem with scaling a serverless application I would need\nto solve next.</p>\n<h3>Sharing code between Lambdas</h3>\n<p>I knew that I wanted to separate my Lambdas based on the resource concern for my APIs but it was\nnatural that some resources needed to know about other resources. I was going to have a user model,\nbut any call to create or join a game would need to check the user who was making the request.</p>\n<p>After some looking into how I might define models of games and users in each lambda without rewriting\nthe class, I found Lambda Layers. These would allow me to deploy code to AWS Lambda which could\nbe used by other lambdas. This solved the problem of declaring dependencies in each of my layers\npackage.json files, needing a db client for each of my layers, and reusing models.</p>\n<p>When using layers, to access to files stored in them from your layer deploy to AWS you require from\nthe <code>/opt/nodejs/{file-path}</code>. This poses a problem when you want to test your application locally.\nTo solve this, you would need to conditionally require from the directory in your local machine or\nthe location in AWS.</p>\n<pre><code>const gamesTable = inAws ? require('/opt/nodejs/tables/gamesTable') : require('../_layers/common/tables/gamesTable');\n</code></pre>\n<p>This can get messy quick. So i opted to do this sort of logic in a single file called <code>layerDeps.js</code>.\nThis abstracted away the logic of knowing what environment I was in, and the locations of the files.</p>\n<pre><code># src/game/layerDeps.js\nconst inAws = !!process.env.AWS_REGION;\nconst gamesTable = inAws ? require('/opt/nodejs/tables/gamesTable') : require('../_layers/common/tables/gamesTable');\nmodule.exports = { gamesTable };\n\n# src/game/handlers/createGame.js\nconst { gamesTable } = require('../layerDeps.js')\n</code></pre>\n<p>Another approach might be to have a config which gave a base path of the file. This has the benefit\nbeing more specific about what files you need, but with the trade off of more lines of code.</p>\n<pre><code># src/game/handlers/createGame.js\nconst { COMMON_LAYER_BASE_PATH } = require('../configs');\nconst gamesTable = require(`${COMMON_LAYER_BASE_PATH}/tables/gamesTable`);\n</code></pre>\n<h3>Feedback loop go ZOOM!</h3>\n<p>When starting with serverless, you might run into calling your endpoint and getting back 500's,\nwithout knowing exactly why. If the lambda does not handle the exception then it won't return anything\nand will always time out. I spent of my time early running into these sorts of issues and learned two\nthings that really started to speed up my feedback loop.</p>\n<p>Firstly, don't be afraid to debug inside the Lambda itself. The AWS Console for Lambda provides\nan IDE, a way to run test events against your lambda and a one click deploy within seconds that will\nallow you to rapidly comment out code and insert logging to narrow down the cause.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/339c291169c00560f71673c45658c28c/29007/lambda-ide.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDUlEQVQoz4WS3W6DMAyFef+Hmna1F0CbOg1BJxU6AiEJJOEv4UxOoWIV2y4+WXbs4yMrUc05iIZzfFUczecb1OsThFJ4eX/GR35Cbwd0XQet9Q+oplqFtm0DrKoQcSFxZTWkEEiSBMZYDNMMay2s6WEpH4ZD+r6HsebWuxJ12uByLWG0xiXPkec5WFlCCBEcGGOCG6XU3SXFzRUtDNFazPOMyKzK4ziCMYa6rsE5DwJ290bN/zFNEyIaWJYlDMZxjDRNkWUZzucziqII4uSWFuyRUgZnj2eINquUUNN2cMppI7kjfrvjoaBzLogu3sN7B+/9veb2OPcn4YZ100C2bfgmQqpbXJE7HvMjqOcbtstnluuFIToAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"lambda-ide\"\n        title=\"lambda-ide\"\n        src=\"/static/339c291169c00560f71673c45658c28c/5a190/lambda-ide.png\"\n        srcset=\"/static/339c291169c00560f71673c45658c28c/772e8/lambda-ide.png 200w,\n/static/339c291169c00560f71673c45658c28c/e17e5/lambda-ide.png 400w,\n/static/339c291169c00560f71673c45658c28c/5a190/lambda-ide.png 800w,\n/static/339c291169c00560f71673c45658c28c/c1b63/lambda-ide.png 1200w,\n/static/339c291169c00560f71673c45658c28c/29007/lambda-ide.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Secondly, you can greatly improve your workflow by having feature tests. You can mock the request\ngiven to function from the API Gateway by calling the function with a body with same key names.\nThen, using <code>jest-dynamodb</code> you can intercept the calls made to dynamoDb so you don't need to run\na docker container. I also used <code>aws-sdk-mock</code> and <code>Sinon.js</code>  when I was calling their APIs to send\nmessages to my websocket connections. Here is a snippet of one my tests.</p>\n<pre><code>it('User has already made a connection with a game returns 403', async () => {\n  const spy = sinon.spy();\n  AwsMock.mock('ApiGatewayManagementApi', 'postToConnection', (params, callback) =>  {\n    spy(JSON.parse(params.Data));\n    callback();\n  });\n  const creatorResponse = await steps.createAUser();\n  const userId = creatorResponse.body.id;\n  const gameResponse = await steps.createAGame({ \n    userId,\n    name: 'Pokemon Lobby',\n    type: 'WouldYouRather',\n  });\n  const gameId = gameResponse.body.id;\n\n  await steps.connectToWss({ gameId, userId, connectionId: uuid() });\n  const connectResponse = await steps.connectToWss({ gameId, userId, connectionId: uuid() });\n\n  expect(spy.notCalled).toBeTruthy();\n  expect(connectResponse).toEqual({\n    statusCode: 403,\n    body: { message: 'CONNECTION_ALREADY_ESTABLISHED' }\n  });\n  AwsMock.restore();\n});\n</code></pre>\n<p>I'd recommend using cucumber if you're going to write feature tests. I didn't think this project\nwas going to get very large, so I didn't invest the time to adding it and created my own testings\nframework.</p>\n<h3>Web Sockets</h3>\n<p>As I became more confident with the serverless technology I wanted to do something more challenging\nwith it. I decided I'd make use of the Web socket gateway and try to implement some sort of real\ntime quiz game. I'd want a user to be able to create a game, share that game through a URL and then\nplay social quiz games, like what music do you rather listening to.</p>\n<p>When using Amazons web sockets, different routes are used to determine what to invoke. For example,\nI have a lambda function called onConnect which takes query string parameters attached to the web\nsocket URL, adds the connection to a connections database, and then broadcasts to all connections also\napart of that game that a new player has joined. This lambda is invoked when the $connect route is\ncalled by connecting to the web socket. I also ended up with a $disconnect route and function which\nhandled the cleanup of the resources.</p>\n<p>I was implementing a time based round game, which meant I needed to handle calling a function every\n~10 seconds which broadcasted the new round to all participants of a game. I could either find a\nservice that would call an endpoint every few seconds which would trigger the new round, or I could\ndo it in one Lambda function which did a setTimeout between each call. I opted for the latter because\nafter some analysis I found that AWS is so cheap, that even if each game ran for a minute, it\nwould still only cost me $1 for every 10,000 games. Even if that is an inefficient use of resources\nit is still cheaper than paying for another service and the invocations to a new lambda for each round.</p>\n<p>Here's a code snippet of my lambda broadcasting a new round every few seconds.</p>\n<pre><code>async function sendRounds({ game, event}) {\n  const socketManager = new SocketManager(event.requestContext);\n  let i = 0;\n  while (i &#x3C; game.numberRounds) {\n    i++;\n    await Promise.all([\n      newRound({ gameId: game.id, socketManager, roundNumber: i }),\n      timeout(game.roundTimeMs)\n    ]);\n  }\n  return;\n}\n</code></pre>","frontmatter":{"date":"August 01, 2021","slug":"/projects/serverless-quizzes/","title":"Serverless Quiz Game","tags":["AWS Lambda","AWS Api Gateway","AWS Cloudformation","DynamoDb","Node.js"]}}},"pageContext":{"id":"69424073-9df9-5609-aab5-55cce25c72f0","frontmatter__slug":"/projects/serverless-quizzes/","__params":{"frontmatter__slug":"projects"}}},"staticQueryHashes":[]}